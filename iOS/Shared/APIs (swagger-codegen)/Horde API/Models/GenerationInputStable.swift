//
// GenerationInputStable.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Foundation

public struct GenerationInputStable: Codable {
    public enum SourceProcessing: String, Codable {
        case img2img
        case inpainting
        case outpainting
    }

    /** The prompt which will be sent to Stable Diffusion to generate an image */
    public var prompt: String
    public var params: ModelGenerationInputStable?
    /** Set to true if this request is NSFW. This will skip workers which censor images. */
    public var nsfw: Bool?
    /** When true, only trusted workers will serve this request. When False, Evaluating workers will also be used which can increase speed but adds more risk! */
    public var trustedWorkers: Bool?
    /** When True, allows slower workers to pick up this request. Disabling this incurs an extra kudos cost. */
    public var slowWorkers: Bool?
    /** If the request is SFW, and the worker accidentaly generates NSFW, it will send back a censored image. */
    public var censorNsfw: Bool?
    public var workers: [String]?
    /** If true, the worker list will be treated as a blacklist instead of a whitelist. */
    public var workerBlacklist: Bool?
    public var models: [String]?
    /** The Base64-encoded webp to use for img2img */
    public var sourceImage: String?
    /** If source_image is provided, specifies how to process it. */
    public var sourceProcessing: SourceProcessing?
    /** If source_processing is set to &#x27;inpainting&#x27; or &#x27;outpainting&#x27;, this parameter can be optionally provided as the  Base64-encoded webp mask of the areas to inpaint. If this arg is not passed, the inpainting/outpainting mask has to be embedded as alpha channel */
    public var sourceMask: String?
    /** If True, the image will be sent via cloudflare r2 download link */
    public var r2: Bool?
    /** If True, The image will be shared with LAION for improving their dataset. This will also reduce your kudos consumption by 2. For anonymous users, this is always True. */
    public var shared: Bool?
    /** If enabled, suspicious prompts are sanitized through a string replacement filter instead. */
    public var replacementFilter: Bool?
    /** When false, the endpoint will simply return the cost of the request in kudos and exit. */
    public var dryRun: Bool?

    public init(prompt: String, params: ModelGenerationInputStable? = nil, nsfw: Bool? = nil, trustedWorkers: Bool? = nil, slowWorkers: Bool? = nil, censorNsfw: Bool? = nil, workers: [String]? = nil, workerBlacklist: Bool? = nil, models: [String]? = nil, sourceImage: String? = nil, sourceProcessing: SourceProcessing? = nil, sourceMask: String? = nil, r2: Bool? = nil, shared: Bool? = nil, replacementFilter: Bool? = nil, dryRun: Bool? = nil) {
        self.prompt = prompt
        self.params = params
        self.nsfw = nsfw
        self.trustedWorkers = trustedWorkers
        self.slowWorkers = slowWorkers
        self.censorNsfw = censorNsfw
        self.workers = workers
        self.workerBlacklist = workerBlacklist
        self.models = models
        self.sourceImage = sourceImage
        self.sourceProcessing = sourceProcessing
        self.sourceMask = sourceMask
        self.r2 = r2
        self.shared = shared
        self.replacementFilter = replacementFilter
        self.dryRun = dryRun
    }

    public enum CodingKeys: String, CodingKey {
        case prompt
        case params
        case nsfw
        case trustedWorkers = "trusted_workers"
        case slowWorkers = "slow_workers"
        case censorNsfw = "censor_nsfw"
        case workers
        case workerBlacklist = "worker_blacklist"
        case models
        case sourceImage = "source_image"
        case sourceProcessing = "source_processing"
        case sourceMask = "source_mask"
        case r2
        case shared
        case replacementFilter = "replacement_filter"
        case dryRun = "dry_run"
    }
}
